diff --git a/audio/decoders/adpcm.cpp b/audio/decoders/adpcm.cpp
index 7def89b..1f7f24f 100644
--- a/audio/decoders/adpcm.cpp
+++ b/audio/decoders/adpcm.cpp
@@ -31,6 +31,14 @@
 
 namespace Audio {
 
+struct ADPCMStatus {
+	// OKI/IMA
+	struct {
+		int32 last;
+		int32 stepIndex;
+	} ima_ch[2];
+};
+
 class ADPCMStream : public RewindableAudioStream {
 protected:
 	Common::SeekableReadStream *_stream;
@@ -41,14 +49,7 @@ protected:
 	const uint32 _blockAlign;
 	uint32 _blockPos[2];
 	const int _rate;
-
-	struct {
-		// OKI/IMA
-		struct {
-			int32 last;
-			int32 stepIndex;
-		} ima_ch[2];
-	} _status;
+	ADPCMStatus _status;
 
 	virtual void reset();
 	int16 stepAdjust(byte);
@@ -194,6 +195,60 @@ int Ima_ADPCMStream::readBuffer(int16 *buffer, const int numSamples) {
 #pragma mark -
 
 
+class Unity_ADPCMStream : public Ima_ADPCMStream {
+protected:
+	uint32 _loopPoint;
+	uint32 _currPos;
+	ADPCMStatus _loopStatus;
+	bool _passedLoopPoint;
+
+public:
+	Unity_ADPCMStream(Common::SeekableReadStream *stream, DisposeAfterUse::Flag disposeAfterUse, uint32 size, int rate, int channels, uint32 blockAlign)
+		: Ima_ADPCMStream(stream, disposeAfterUse, size, rate, channels, 0), _loopPoint(blockAlign), _currPos(0) {
+		memset(&_loopStatus, 0, sizeof(_loopStatus));
+	}
+
+	virtual int readBuffer(int16 *buffer, const int numSamples);
+	virtual bool rewind();
+};
+
+int Unity_ADPCMStream::readBuffer(int16 *buffer, const int numSamples) {
+	int samples;
+	byte data;
+
+	assert(numSamples % 4 == 0);
+	bool stereo = _channels == 2;
+
+	for (samples = 0; samples < numSamples && !_stream->eos() && _stream->pos() < _endpos; samples += 4) {
+		data = _stream->readByte();
+		if (_currPos == _loopPoint)
+			memcpy(&_loopStatus.ima_ch[0], &_status.ima_ch[0], sizeof(_status.ima_ch[0]));
+		buffer[samples] = decodeIMA(data & 0x0f);
+		buffer[samples + (stereo ? 2 : 1)] = decodeIMA((data >> 4) & 0x0f);
+
+		data = _stream->readByte();
+		if (_currPos + (stereo ? 0 : 2) == _loopPoint)
+			memcpy(&_loopStatus.ima_ch[stereo ? 1 : 0], &_status.ima_ch[stereo ? 1 : 0], sizeof(_status.ima_ch[0]));
+		buffer[samples + (stereo ? 1 : 2)] = decodeIMA(data & 0x0f, stereo ? 1 : 0);
+		buffer[samples + 3] = decodeIMA((data >> 4) & 0x0f, stereo ? 1 : 0);
+
+		_currPos += 2;
+	}
+	return samples;
+}
+
+bool Unity_ADPCMStream::rewind() {
+	if (_stream->pos() < _startpos + (int)_loopPoint)
+		return true;
+	memcpy(&_status, &_loopStatus, sizeof(_status));
+	_stream->seek(_startpos + _loopPoint);
+	_currPos = _loopPoint;
+	return true;
+}
+
+#pragma mark -
+
+
 class Apple_ADPCMStream : public Ima_ADPCMStream {
 protected:
 	// Apple QuickTime IMA ADPCM
@@ -838,6 +893,8 @@ RewindableAudioStream *makeADPCMStream(Common::SeekableReadStream *stream, Dispo
 		return new Tinsel8_ADPCMStream(stream, disposeAfterUse, size, rate, channels, blockAlign);
 	case kADPCMIma:
 		return new Ima_ADPCMStream(stream, disposeAfterUse, size, rate, channels, blockAlign);
+	case kADPCMUnity:
+		return new Unity_ADPCMStream(stream, disposeAfterUse, size, rate, channels, blockAlign);
 	case kADPCMApple:
 		return new Apple_ADPCMStream(stream, disposeAfterUse, size, rate, channels, blockAlign);
 	case kADPCMDK3:
diff --git a/audio/decoders/adpcm.h b/audio/decoders/adpcm.h
index 38ec870..2d29a9c 100644
--- a/audio/decoders/adpcm.h
+++ b/audio/decoders/adpcm.h
@@ -60,6 +60,7 @@ enum typesADPCM {
 	kADPCMTinsel6,             // 6-bit ADPCM used by the Tinsel engine
 	kADPCMTinsel8,             // 8-bit ADPCM used by the Tinsel engine
 	kADPCMIma,                 // Standard IMA ADPCM
+	kADPCMUnity,               // IMA ADPCM used by the Final Unity engine
 	kADPCMApple,               // Apple QuickTime IMA ADPCM
 	kADPCMDK3                  // Duck DK3 IMA ADPCM
 };
